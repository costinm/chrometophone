/*
 */
package com.google.android.chrometophone.server;

import com.google.appengine.api.oauth.OAuthRequestException;
import com.google.appengine.api.oauth.OAuthService;
import com.google.appengine.api.oauth.OAuthServiceFactory;
import com.google.appengine.api.oauth.OAuthServiceFailureException;
import com.google.appengine.api.users.User;
import com.google.appengine.api.users.UserService;
import com.google.appengine.api.users.UserServiceFactory;

import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.net.URL;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Common code and helpers to handle a request and manipulate device info.
 */
public class RequestInfo {
    private static final Logger log =
            Logger.getLogger(RequestInfo.class.getName());
    private static final String ERROR_STATUS = "ERROR";
    private static final String LOGIN_REQUIRED_STATUS = "LOGIN_REQUIRED";

    static final String CLIENT_ID = "922510834487-26lfgg41esep0j076be36vtt8282id9p.apps.googleusercontent.com";
    static final String CLIENT_ID_DEV = "922510834487-26lfgg41esep0j076be36vtt8282id9p.apps.googleusercontent.com";

    public List<DeviceInfo> devices = new ArrayList<DeviceInfo>();

    public String userName;
    public String unauthenticatedAccount;

    private ServletContext ctx;
    public String deviceRegistrationID;

    // Request parameters - transitioning to JSON, but need to support existing
    // code.
    Map<String, String[]> parameterMap;
    JSONObject jsonParams;


    public boolean isAuth() {
        return userName != null;
    }

    static String[] NO_AUTH_TYPE_TOKEN = new String[0];

    /**
     * Authenticate the user, check headers and pull the registration data.
     *
     * @return null if authentication fails.
     * @throws IOException
     */
    public static RequestInfo processRequest(HttpServletRequest req,
                                             HttpServletResponse resp, ServletContext ctx) throws IOException {

        // Basic XSRF protection
        if (req.getHeader("X-Same-Domain") == null) {
            resp.setStatus(400);
            resp.getWriter().println(ERROR_STATUS + " (Missing X-Same-Domain header)");
            log.warning("Missing X-Same-Domain");
            return null;
        }

        RequestInfo ri = new RequestInfo();
        ri.ctx = ctx;

        if (req.getContentType().startsWith("application/json")) {
            Reader reader = req.getReader();
            // where is readFully ?
            char[] tmp = new char[2048];
            StringBuffer body = new StringBuffer();
            while (true) {
                int cnt = reader.read(tmp);
                if (cnt <= 0) {
                    break;
                }
                body.append(tmp, 0, cnt);
            }
            try {
                ri.jsonParams = (JSONObject) new JSONParser().parse(body.toString());
                //new JSONObject(body.toString());
                //} catch (JSONException e) {
                //    resp.setStatus(500);
                //    return null;
            } catch (ParseException e) {
                resp.setStatus(500);
                return null;
            }
        } else {
            @SuppressWarnings("unchecked")
            Map<String, String[]> castMap = req.getParameterMap();
            ri.parameterMap = castMap;
        }

        if (!ri.authenticate(req, resp)) {
            return null;
        }

        ri.deviceRegistrationID = ri.getParameter("devregid");
        if (ri.deviceRegistrationID != null) {
            ri.deviceRegistrationID = ri.deviceRegistrationID.trim();
            if ("".equals(ri.deviceRegistrationID)) {
                ri.deviceRegistrationID = null;
            }
        }

        // Load data from DB
        if (ctx != null) {
            ri.initDevices(ctx);
        }

        // Verify the saved device info exists and matches what was sent
        if (!postAuthenticate(req, resp, ri)) {
            return null;
        }
        return ri;
    }

    /**
     * Storage key, based on account and hash of 'deviceId' parameter.
     */
    public String getKey() {
        // Old version: deviceId was a random generated by chrome, and
        // the AndroidId. Keep accepting it for older phone versions.
        String deviceId = getParameter("deviceId");

        // New version: use instanceID, or the registrationID for old chrome
        if (deviceId == null && deviceRegistrationID != null) {
            String[] regidComponents = deviceRegistrationID.split(":");
            if (regidComponents.length > 0) {
                // First part of the IID should be as stable as the android ID
                deviceId = regidComponents[0];
            }
        }
        if (deviceId == null ||
                (userName == null && unauthenticatedAccount == null)) {
            return null;
        }
        return ((userName == null) ? unauthenticatedAccount : userName) +
                "#" +
                Long.toHexString(Math.abs(deviceId.hashCode()));
    }

    /**
     * For requests not authenticated with JWT token (from android)
     * or OAuth2 (chrome), fall back to checking the InstanceID/
     * registrationID.
     */
    private static boolean postAuthenticate(HttpServletRequest req, HttpServletResponse resp, RequestInfo ri) throws IOException {
        if (ri.unauthenticatedAccount != null) {
            // Find the device.
            for (DeviceInfo device : ri.devices) {
                String regid = ri.deviceRegistrationID;
                if (regid.equals(device.getDeviceRegistrationID())) {
                    // Found the device, regid matches - same device
                    ri.userName = ri.unauthenticatedAccount;
                    log.info("Authenticate using IID cookie " + ri.userName);
                    return true;
                }
            }

            resp.setStatus(200);
            resp.getWriter().println(LOGIN_REQUIRED_STATUS);
            log.info("Missing user, login required");
            return false;
        }
        return true;
    }

    /**
     * Implement multiple auth methods. This may result in a partial authentication,
     * where after loading the info from database we need to do additional
     * checks.
     */
    private boolean authenticate(HttpServletRequest req, HttpServletResponse resp) throws IOException {

        // Android: use ID (JWT) token, in authorization header.
        String authorization = req.getHeader("Authorization");
        String[] typeToken = (authorization == null) ? NO_AUTH_TYPE_TOKEN : authorization.split(" ");
        if (typeToken.length == 2) {
            userName = checkIdToken(typeToken[1]);
            if (userName != null) {
                log.info("Authenticated android user " + userName + " " + typeToken[0]);
                return true;
            }
        }

        // New chrome: OAuth2 token for registration/send
        String authParam = getParameter("auth");
        if (authParam != null) {
            // GoogleLogin in chrome extension or webpush page
            userName = checkIdToken(authParam);

            if (userName != null) {
                // TODO: populate a refresh token, and check it periodically
                // for the case permission is revoked or account disabled
                // This will require a cron job or some notifications
                log.info("Authenticated chrome user " + userName);
                return true;
            }
        }

        OAuthService oauth = OAuthServiceFactory.getOAuthService();
        String scope = "https://www.googleapis.com/auth/userinfo.email";

        try {
            User user = oauth.getCurrentUser(scope);
            String tokenAudience = oauth.getClientId(scope);
            if (CLIENT_ID.equals(tokenAudience) ||
                CLIENT_ID_DEV.equals(tokenAudience)) {
                // TODO: match one or the other based on domain name
                userName = user.getEmail();
                log.info("Authenticated based on email scope " + userName);

                return true;
            }
            // proceed with authenticated user
            // ...
        } catch (OAuthRequestException ex) {
            // handle auth error
            // ...
        } catch (OAuthServiceFailureException ex) {
            // optionally, handle an oauth service failure
            // ...
        }

        // Chrome: user + deviceID + chrome token (will be chrome GCM regid)
        unauthenticatedAccount = getParameter("account");
        if (unauthenticatedAccount != null) {
            return true; // Will be authenticated after loading devices
        }

        // Old style - will stop working when Oauth1 is killed
        userName = legacyAppengineAuth();
        if (userName != null) {
            return true;
        }

        resp.setStatus(200);
        resp.getWriter().println(LOGIN_REQUIRED_STATUS);
        log.info("Missing user, login required");
        return false;
    }

    private static String legacyAppengineAuth() {
        User appengineUser = null;
        // Legacy - will be shut down soon.
        OAuthService oauthService = OAuthServiceFactory.getOAuthService();
        try {
            appengineUser = oauthService.getCurrentUser();
            log.log(Level.INFO, "Registered with getCurrentUser() " + appengineUser);
        } catch (Throwable t) {
            // Try next scope
        }


        if (appengineUser == null) {
            // Try ClientLogin
            UserService userService = UserServiceFactory.getUserService();
            appengineUser = userService.getCurrentUser();
        }

        return (appengineUser == null) ? null : appengineUser.getEmail();
    }

    /**
     * Process a id_token, access_token or token_handle, by using the tokeninfo
     * endpoint
     */
    private static String checkIdToken(String authParam) {
        try {
            URL url = new URL("https://www.googleapis.com/oauth2/v3/tokeninfo?id_token="
                    + authParam);
            InputStream is = url.openConnection().getInputStream();
            JSONObject obj = (JSONObject) new JSONParser().parse(new InputStreamReader(is));

            // TODO: verify audience!
            log.info("Got: " + obj.toJSONString());

            return (String) obj.get("email");
        } catch (IOException e) {
            log.log(Level.WARNING, "Error checking id token", e);
            return null;
        } catch (ParseException e) {
            log.log(Level.WARNING, "Error checking id token " + authParam, e);
            return null;
        }
    }

    public String getParameter(String name) {
        if (jsonParams != null) {
            return (String) jsonParams.get(name);
        } else {
            String res[] = parameterMap.get(name);
            if (res == null || res.length == 0) {
                return null;
            }
            return res[0];
        }
    }

    /**
     * Authenticate using the req, fetch devices.
     */
    private RequestInfo() {
    }

    @Override
    public String toString() {
        return userName + " " + devices.size() + " " + jsonParams;
    }

    public RequestInfo(String userN, ServletContext ctx) {
        this.userName = userN;
        this.ctx = ctx;
        if (ctx != null) {
            initDevices(ctx);
        }
    }

    private void initDevices(ServletContext ctx) {
        devices = Storage.get(ctx).loadDevices(
                userName != null ? userName : unauthenticatedAccount);
    }

    // We need to iterate again - can be avoided with a query.
    // delete will fail if the pm is different than the one used to
    // load the object - we must close the object when we're done
    public void deleteRegistration(String regId, String type) {
        Storage.get(ctx).deleteRegistration(userName, regId, type);
    }
}
